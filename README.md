Так как всего ip адресов 2^32, а файл из примера был очень большим, то я решил, что можно создать массив для каждого ip.
Изначально я создал четырехмерный массив (в нем удобно обращаться к каждому элементу) из BooleanArray. Такой массив
занимал 4-4,5 Гб оперативной памяти. Сама
программа выполнялась 30-35 минут.

Вспомнив, что Boolean в данном случае занимает целый байт, а я не такой богатый на память, то я решил использовать
ByteArray, а каждое число "кодировать" в определенный бит информации. После чего размер занимаемой приложением памяти
стал уже около 900 Мб.

Так как четырехмерный массив занимает больше места, то я решил использовать один массив Int 2^27, а в каждом int стал
хранить 32 уникальных ip адреса. После этого размер занимаемой памяти стал уже около 550 Мб.

Дальше хотелось поработать над скоростью выполнения программы. Здесь я решил использовать kotlin coroutines и channel
для обмена информацией между ними. Запустив чтение из файла и запись в разных корутинах я получил .... замедление
приложения. Тут подумав, что каждую строку запихивать в channel не самая гениальная идея, которая могла прийти. Поэтому
решил кидать сразу по 1000 ip. Программа ускорилась до 27 минут, но все еще не то.

Посмотрев, что чтение файла гораздо опережает его запись в массив, я распараллелил запись. Для этого стал использовать
AtomicIntegerArray. Выполнение ускорилось до 7,5 минут. Кажется это уже лучше.

PS Для маленьких файлов приложение все равно будет требовать 500 Мб оперативной памяти. Можно принимать во внимание
размер файла и не создавать огромный массив, а использовать, например, наивный алгоритм.